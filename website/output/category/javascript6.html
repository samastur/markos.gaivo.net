<!DOCTYPE html>
<html lang="en">
<head>
        <title>A notch above a monkey</title>
        <meta charset="utf-8" />
        <link rel="shortcut icon" href="theme/img/markos.ico" />

        <link href="http://fast.fonts.com/cssapi/aee9b60b-8e94-47f8-b586-3ecbfab51d1c.css" rel="stylesheet" type="text/css" />
        <link rel="stylesheet" type="text/css" href="theme/css/home.css" media="screen" title="Light theme" />
        <link rel="alternate stylesheet" type="text/css" href="theme/css/home_dark.css" media="screen" title="Dark theme" />
        <link rel="stylesheet" href="theme/css/ipad.css" media="only screen and (min-device-width : 768px) and (max-device-width : 1024px)">
        <link rel="stylesheet" type="text/css" href="theme/css/smallscreen.css" media="only screen and (max-width: 700px)" />

        <link href="/articles/feeds/atom.xml" type="application/atom+xml" rel="alternate" title="A notch above a monkey Full Atom Feed" />
        <link href="/articles/feeds/rss.xml" type="application/rss+xml" rel="alternate" title="A notch above a monkey Full RSS Feed" />
</head>

<body>

<h2>Articles in the Javascript category</h2>

<section class="envelope posts">
    <header>
        <h1><a href="/">A notch above a monkey <strong></strong></a></h1>
    </header><!-- /#banner -->

    <nav class="colophon">
        <h1>By Marko Samastur</h1>
        <ul>
            <li><a href="/">About me</a></li>
            <li><a href="http://markos.gaivo.net/blog/?feed=atom">Subscribe</a></li>
        </ul>
    </nav>

        <article class="hentry">
            <h1 class="entry-title storytitle"><a href="/javascript-timing-conflicts.html" rel="bookmark" title="Permalink to Javascript timing conflicts">Javascript timing conflicts</a></h1>

            <div class="entry-content post-text">
                <p>Play with fire and you'll get burned.</p>
<p>I've just spent two days hunting a bug that just didn't make sense. No
matter what I did, there was at least one browser, which didn't want to
behave properly and it was driving me nuts.</p>
<p>Finally I gave up and decided there's nothing wrong with my code and the
fault must be with the browser. And so it was, up to a point. Or not,
depending on your point of view.</p>
<p>The problem was a timing conflict resulting from a use of <a href="http://markos.gaivo.net/blog/?p=12" title="Description of technique">framestack
technique</a>
and the way modern browsers work. Browsers don't wait for the whole page
with its data to load, before they display it to users. They display as
reasonable presentation of received data as possible while they are
trying to load the rest. For example, onload handler set to body tag is
triggered when body of HTML document has loaded, but possibly before
images and other external resources have. When they do, page layout
might change somewhat and if your script is reading and using layout
data in the meantime, it's quite likely it'll end up using wrong values.</p>
<p>The easiest (and right) way to fix this is to start javascript with
<em>window.onload</em>, which is triggered when everything has loaded. This
might be a problem, if you're using something like framestack to avoid
reloading page on subsequent visits, but at least in my case I've
decided that the cleanest and easiest solution was to use window.onload
and just force reload of problematic page on each visit.</p>
<p>It's also possible to get in similar timing conflicts by using
<em>innerHTML</em> method. If you try to stuck a large piece of HTML inside a
page using innerHTML call, you may encounter an unwelcome surprise.
Reason for this is that at least some browsers don't wait to parse and
insert data in DOM before they proceed to the next statement. Injection
delay is usually barely noticeable, but big enough for statements that
manipulate inserted data to fail, if they are in close proximity to
innerHTML call.</p>
<p>You can't necessarily avoid innerHTML problems with window.onload, but
you can by using (more cumbersome) DOM methods.</p>
<p>It still annoys me though that I knew all of this and wasted two days
just because I didn't think of it.</p>
            </div><!-- /.entry-content -->

            <footer class="post-metadata">
                <ul>
                    <li>Published on <time datetime="2005-09-17T19:01:00+02:00">Sat 17 September 2005</time> </li>
                    <li><a href="/javascript-timing-conflicts.html">Add your comment</a></li>
                </ul>
            </footer>
        </article>
        <article class="hentry">
            <h1 class="entry-title storytitle"><a href="/framestack-technique-and-accessibility.html" rel="bookmark" title="Permalink to Framestack technique and accessibility">Framestack technique  and accessibility</a></h1>

            <div class="entry-content post-text">
                <p>I like to spend my vacation as far from crowds as possible and Ireland
was perfect spot for this. Sadly I had to stay connected to my work this
year so I had my laptop with me. However, we often stayed at places,
where we could forget a broadband connection and could be happy to catch
a GSM signal.</p>
<p>So I spent a lot of time being connected over GPRS and quickly started
to dislike huge pages that take ages to load (if they don't timeout) and
cost you a fortune. It seemed to validate our decision to make our
interfaces as fast and small as possible and to do this by <strong>loading
data only when needed and never twice</strong>.</p>
<p>We became convinced we’ll need frames to do that or one huge page to
store
everything.^<a href="#fmstck1-2005-08-27">1</a><a name="fmstck01-2005-08-27"></a>^
Since we were under false impression that accessibility went out of the
window with Javascript, we tried to push things as far as possible and
frames seemed a more manageable and less evil way of doing things.</p>
<p><strong>Description of approach</strong></p>
<p>The idea was simple. Load parts of UI in separate frames, when you first
need it and switch to it later, if you need it again. Switching is done
by manipulating cols/rows attribute of frameset node by setting a value
that hides all frames except the one you want to show, which of course
occupies whole available space. You can
<a href="http://markos.gaivo.net/examples/framestack.zip">download</a> or <a href="http://markos.gaivo.net/examples/framestack/" title="Framestack demo">look
at</a> a
simple demo and study it at your leisure.</p>
<p><em>This is just a technical demo that works in Firefox and Safari and
takes certain liberties when it comes to achieving its goals. Real
implementation would necessarily be more complicated and if there's
enough interest, will be a subject of a separate article.</em></p>
<p>Those not interested in technical details of the approach can just
proceed to the next section.</p>
<p>Everything of interest is happening in index.html, which defines frames
for this demo and also contains Javascript needed to enable it. Relevant
part of HTML:<br />
<codeins ="framestack1"></codeins></p>
<p>It probably doesn't need much explanation, since it just defines
frameset with 3 frames, assigns IDs to them and uses frameborder
attribute to hide borders. For some reason I had to use non-standard
frameset frameborder to really get rid of all borders. It loads and
displays second frame and loads stub pages in first and third frame.</p>
<p>Now we just need a following Javascript function:<br />
<codeins ="framestack2"></codeins></p>
<p>It takes an ID of a frame to which we are switching as an argument,
first makes a sanity check and then initializes a few variables. Action
holds a reference to frameset and variable frame has a reference to the
new frame. We also have to check if we actually have those references,
since it doesn't make sense to proceed if we don't.</p>
<p>Then we loop through frames and set size of each to 0, unless we found
the right frame. We first maximize its size and then check, if the frame
has been loaded yet. We use frameID plus html extension as an easy way
to connect frame with its filename, but could make this more complicated
if needed. In case it hasn't been loaded yet (its source is a different
file), we load it.</p>
<p><strong>Analysis</strong></p>
<p>Benefits of this approach:</p>
<ul>
<li>fast</li>
<li>smaller files which are loaded when needed result in cheaper use
    when bandwidth is metered (e.g. GPRS in most of Europe)</li>
<li>keeps state since it leaves hidden pages intact, which at least for
    us is more often than not the preferred behavior (clearly seen in
    demo by paying attention to dates)</li>
</ul>
<p>Downsides of this approach:</p>
<ul>
<li>it's most likely unaccessible</li>
<li>it doesn't work at all without Javascript</li>
<li>can't bookmark and other reasons against frames in general</li>
</ul>
<p>And this is where I cry for help. Jaws is prohibitively expensive, so
I'd really appreciate anyone capable of doing so to try provided demo in
a screen reader and report his findings. I don't expect good news, but
would like to know how bad it really is.</p>
<p>I'd also appreciate any ideas on how to make this thing actually
accessible. I don't see how I could come to this approach by following
Jeremy's advice of first building an html version of a tool and then
improve it with
Javascript.^<a href="#fmstck2-2005-08-27">2</a><a name="fmstck02-2005-08-27"></a>^
Hence I don't know how to backtrack to that happy state either.</p>
<p>Author of the first solution will receive a book of his/her choice, a
drink on me when we meet and my eternal gratitude.</p>
<p>Notes:</p>
<ol>
<li><a name="fmstck1-2005-08-27"></a>Of course we were wrong. There are
    other approaches to load HTML and Javascript dynamically. However,
    with all to me known techniques you keep more or less same problems
    as with framestack approach and result is arguably more difficult to
    maintain. The only thing in my opinion that might make such
    approaches worth while is, if it’s more accessible and that I
    honestly don’t know. <a href="#fmstck01-2005-08-27">↑</a></li>
<li><a name="fmstck2-2005-08-27"></a>I do think his advice is sound and
    shouldn't be lightly or often discarded. <a href="#fmstck02-2005-08-27">↑</a></li>
</ol>
            </div><!-- /.entry-content -->

            <footer class="post-metadata">
                <ul>
                    <li>Published on <time datetime="2005-08-27T18:40:00+02:00">Sat 27 August 2005</time> </li>
                    <li><a href="/framestack-technique-and-accessibility.html">Add your comment</a></li>
                </ul>
            </footer>
        </article>
        <article class="hentry">
            <h1 class="entry-title storytitle"><a href="/looping-through-getelementsbytagname-list.html" rel="bookmark" title="Permalink to Looping through getElementsByTagName list">Looping through getElementsByTagName list</a></h1>

            <div class="entry-content post-text">
                <p>There's a small quirk that developers hit now and then when they are
processing a list of elements returned by getElementsByTagName function.
Usual, but still unexpected behavior is that not all elements of the
list have been processed and if you are using javascript console, it
might complain that there's no element in the list at index, where
you're certain it should be.</p>
<p>The reason for this is that returned list of elements is not really a
list. It's a live view of matching elements. If you delete one of them
in document, it will be removed from the list as well. List will become
shorter and some elements in it may change their position to fill empty
slot formerly occupied by deleted element.</p>
<p>Therefore, if you loop through such a list and its possible that you
might remove current element, it's best to loop from last element to the
first. This keeps positions stable and predictable even when you delete.</p>
<p>It can be a bit trickier to handle if you add matching elements inside
such loop. Sadly there's no easy solution that would work all the time
and you have to take in account your situation.</p>
            </div><!-- /.entry-content -->

            <footer class="post-metadata">
                <ul>
                    <li>Published on <time datetime="2005-08-20T15:37:00+02:00">Sat 20 August 2005</time> </li>
                    <li><a href="/looping-through-getelementsbytagname-list.html">Add your comment</a></li>
                </ul>
            </footer>
        </article>

<p class="paginator">
        <a href="/category/javascript5.html">&laquo;</a>
    Page 6 / 7
        <a href="/category/javascript7.html">&raquo;</a>
</p>
</section><!-- /#content -->

    <footer>
        <ul>
            <li>&copy; 2005-2015 Marko Samastur</li>
            <li><a href="/articles/feeds/rss.xml" rel="alternate" title="A notch above a monkey Full RSS Feed">Entries feed</a></li>
        </ul>
        <a href="/"><img src="/img/markos_light_small_bg.png" alt="logo" class="mini-logo" /></a>
    </footer>
</body>
</html>