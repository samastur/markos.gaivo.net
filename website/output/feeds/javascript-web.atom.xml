<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>A notch above a monkey</title><link href="/" rel="alternate"></link><link href="/articles/feeds/javascript-web.atom.xml" rel="self"></link><id>/</id><updated>2010-04-01T10:59:00+02:00</updated><entry><title>Using canvas and Javascript to blur images</title><link href="/using-canvas-and-javascript-to-blur-images.html" rel="alternate"></link><updated>2010-04-01T10:59:00+02:00</updated><author><name>markos</name></author><id>tag:,2010-04-01:using-canvas-and-javascript-to-blur-images.html</id><summary type="html">&lt;p&gt;&lt;html&gt;
 &lt;body&gt;
  &lt;div&gt;
   &lt;p&gt;
    I admire the look and feel of
    &lt;a href="http://www.mikematas.com/"&gt;
     Mike Matas’ new website
    &lt;/a&gt;
    . It is really well thought through. I was also intrigued by how he did it, especially after getting a pop-up on my first visit advising me to use a more modern browser than a recent version of Firefox.
   &lt;/p&gt;
   &lt;p&gt;
    There is no point in speculating why some of its features don’t work in more browsers. But I was surprised to see that blurred images are served that way and don’t get blurred in browser. I am playing with an idea of implementing a gallery inspired by Mike’s work, but I would like to reduce manual labor needed for maintaining it.
   &lt;/p&gt;
   &lt;p&gt;
    So I wrote a function that blurs an image on canvas. You can
    &lt;a href="http://markos.gaivo.net/examples/canvas_blur/" title="Javascript blur demo page"&gt;
     see it in action
    &lt;/a&gt;
    or copy its code, if you find it useful.
   &lt;/p&gt;
   &lt;p&gt;
    The algorithm used is described in
    &lt;a href="http://web.archive.org/web/20060718054020/http://www.acm.uiuc.edu/siggraph/workshops/wjarosz_convolution_2001.pdf" title="Link to PDF version of paper"&gt;
     2001 paper
    &lt;/a&gt;
    by Wojciech Jarosz. Page contains two implementations, second trading algorithm purity for in my opinion nicer code. Increase number of passes or run it few times over an image, if you need a blurrier result.? Please ask, if you need help with its use.
   &lt;/p&gt;
   &lt;p&gt;
    I also measured its speed to see if it fits my needs. That brought a new surprise. Firefox 3.5.8? on my Linux powered VAIO with 1.2GHz processor blurs image twice as fast as same browser on a Mac with a 2.8Ghz processor. Numbers between runs may vary slightly, but never much. No idea why this is happening, since all functions do is some basic math over items in array that should be well optimized everywhere.
   &lt;/p&gt;
   &lt;p&gt;
    I am sure somebody can optimize it further, but I find it good enough for my use. Image isn’t very blurred after one pass, but one pass over a small image is also a good way to measure how fast a particular computer-browser combination is. On fast combinations I might go for multiple passes over images in view, but fall back to a single pass or no pass on slower systems.
   &lt;/p&gt;
   &lt;div class="zemanta-pixie"&gt;
    &lt;a class="zemanta-pixie-a" href="http://reblog.zemanta.com/zemified/4b7c629c-fdbe-4190-ade4-e240b1b3755a/" title="Reblog this post [with Zemanta]"&gt;
     &lt;img alt="Reblog this post [with Zemanta]" class="zemanta-pixie-img" src="http://img.zemanta.com/reblog_e.png?x-id=4b7c629c-fdbe-4190-ade4-e240b1b3755a"/&gt;
    &lt;/a&gt;
   &lt;/div&gt;
  &lt;/div&gt;
 &lt;/body&gt;
&lt;/html&gt;&lt;/p&gt;</summary></entry><entry><title>Javascript: The Good Parts and string.split problem</title><link href="/javascript-the-good-parts-and-stringsplit-problem.html" rel="alternate"></link><updated>2009-03-29T11:15:00+02:00</updated><author><name>markos</name></author><id>tag:,2009-03-29:javascript-the-good-parts-and-stringsplit-problem.html</id><summary type="html">&lt;p&gt;&lt;html&gt;
 &lt;body&gt;
  &lt;div&gt;
   &lt;p&gt;
    I just read
    &lt;a class="zem_slink" href="http://crockford.com/" rel="homepage" title="Douglas Crockford"&gt;
     Douglas Crockford
    &lt;/a&gt;
    ‘s book
    &lt;a href="http://www.amazon.com/gp/product/0596517742?ie=UTF8&amp;amp;tag=devel-20&amp;amp;linkCode=as2&amp;amp;camp=1789&amp;amp;creative=390957&amp;amp;creativeASIN=0596517742"&gt;
     JavaScript: The Good Parts
    &lt;/a&gt;
    &lt;img alt="" border="0" height="1" src="http://www.assoc-amazon.com/e/ir?t=devel-20&amp;amp;l=as2&amp;amp;o=1&amp;amp;a=0596517742" style="border:none !important; margin:0px !important;" width="1"/&gt;
    . It’s what a technical book should be. Concise yet full of useful information as a result of clear scope and sticking to it. If my experience is anything to go by, then there are not many Javascript programmers who wouldn’t benefit from it.
   &lt;/p&gt;
   &lt;p&gt;
    I did found one bit that wasn’t quite right. On pages 91-92 Douglas discusses
    &lt;em&gt;
     string.split
    &lt;/em&gt;
    method, which can take a regular expression as a separator with which to split string. Douglas rightly points out that if regular expression includes capturing group (stuff between paranthesis like
    &lt;em&gt;
     b(mmm)c
    &lt;/em&gt;
    ), then strings matching those groups will be included in the split.
   &lt;/p&gt;
   &lt;p&gt;
    However Douglas is not completely correct when he says that some implementations drop empty strings in the output array when separator is regular expression. If you run
    &lt;a href="http://markos.gaivo.net/examples/jssplit/index.html"&gt;
     this demo
    &lt;/a&gt;
    in
    &lt;a class="zem_slink" href="http://www.firefox.com/" rel="homepage" title="Mozilla Firefox 3"&gt;
     Firefox3
    &lt;/a&gt;
    and IE7, you’ll see that IE7 drops even non-empty strings from capturing groups, while Firefox3 includes them.
   &lt;/p&gt;
   &lt;p&gt;
    Still, I would find a bug in my code faster this week if I read his book sooner.
   &lt;/p&gt;
   &lt;div class="zemanta-pixie"&gt;
    &lt;a class="zemanta-pixie-a" href="http://reblog.zemanta.com/zemified/098a0fec-e31c-40fe-a1d4-701ecad46969/" title="Zemified by Zemanta"&gt;
     &lt;img alt="Reblog this post [with Zemanta]" class="zemanta-pixie-img" src="http://img.zemanta.com/reblog_e.png?x-id=098a0fec-e31c-40fe-a1d4-701ecad46969"/&gt;
    &lt;/a&gt;
    &lt;span class="zem-script more-related"&gt;
     &lt;script src="http://static.zemanta.com/readside/loader.js" type="text/javascript"&gt;
     &lt;/script&gt;
    &lt;/span&gt;
   &lt;/div&gt;
  &lt;/div&gt;
 &lt;/body&gt;
&lt;/html&gt;&lt;/p&gt;</summary></entry><entry><title>Triggering a server request on onunload event</title><link href="/triggering-a-server-request-on-onunload-event.html" rel="alternate"></link><updated>2008-03-26T16:32:00+01:00</updated><author><name>markos</name></author><id>tag:,2008-03-26:triggering-a-server-request-on-onunload-event.html</id><summary type="html">&lt;p&gt;&lt;html&gt;
 &lt;body&gt;
  &lt;div&gt;
   &lt;p&gt;
    A while ago I tried to trigger an AJAX call to server in
    &lt;em&gt;
     onunload
    &lt;/em&gt;
    handler and failed miserably. It simply didn’t work in major browsers and I filled the idea under can’t-be-done.
   &lt;/p&gt;
   &lt;p&gt;
    I recently got another reason to revisit this problem and came up with a new-old idea. Since in my case I don’t care about server response, I don’t actually need XMLHttpRequest. Any technique that triggers a call to server is good enough, so why not try creating an image and setting its
    &lt;em&gt;
     url
    &lt;/em&gt;
    attribute to appropriate value.
   &lt;/p&gt;
   &lt;p&gt;
    It turns out that this works almost everywhere. It worked pretty flawlessly in Firefox, Opera and Internet Explorer, but it doesn’t work in Safari and Konqueror, which makes me think that KHTML/Webkit family of browsers in general don’t support it.
   &lt;/p&gt;
   &lt;p&gt;
    This is not its only limitation. Technique obviously works only for GET calls, which is frowned upon and generally dangerous for actions that change state. I also suspect it works less well on slower computers or networks so you might need to delay event handler ending by buying some time with needless processing after you’ve set
    &lt;em&gt;
     url
    &lt;/em&gt;
    attribute.
   &lt;/p&gt;
   &lt;p&gt;
    Still, it might be another useful hack to have if you can live with its limitations.
   &lt;/p&gt;
  &lt;/div&gt;
 &lt;/body&gt;
&lt;/html&gt;&lt;/p&gt;</summary></entry><entry><title>Javascript events on tablet</title><link href="/javascript-events-on-tablet.html" rel="alternate"></link><updated>2007-12-16T18:14:00+01:00</updated><author><name>markos</name></author><id>tag:,2007-12-16:javascript-events-on-tablet.html</id><summary type="html">&lt;p&gt;&lt;html&gt;
 &lt;body&gt;
  &lt;div&gt;
   &lt;p&gt;
    I’ve been curious about interface possibilities and limitations of non-desktop environments like my Nokia tablet for a while, especially as they pertain to web. Pen on a touchscreen obviously doesn’t have to leave a “trail” of traversal like a mouse does. You also don’t have several mouse buttons at your disposal.
   &lt;/p&gt;
   &lt;p&gt;
    So I made a simple
    &lt;a href="http://markos.gaivo.net/examples/jsenvtest.html"&gt;
     test page
    &lt;/a&gt;
    to see how some of more interesting events get caught.
   &lt;/p&gt;
   &lt;p&gt;
    The result on my 770 was quite disappointing while also expected. I’ll summarize it for those who don’t have a tablet. Touching a screen generates
    &lt;em&gt;
     mousemove
    &lt;/em&gt;
    event and sometimes
    &lt;em&gt;
     mouseover
    &lt;/em&gt;
    , but you never get a
    &lt;em&gt;
     mouseout
    &lt;/em&gt;
    event. If touched briefly enough, it’ll also generate
    &lt;em&gt;
     mousedown
    &lt;/em&gt;
    ,
    &lt;em&gt;
     mouseup
    &lt;/em&gt;
    and
    &lt;em&gt;
     click
    &lt;/em&gt;
    event in this order.
   &lt;/p&gt;
   &lt;p&gt;
    You won’t get a
    &lt;em&gt;
     mousedown
    &lt;/em&gt;
    and
    &lt;em&gt;
     mouseup
    &lt;/em&gt;
    events until
    &lt;em&gt;
     click
    &lt;/em&gt;
    . If you keep pressing the screen without moving, you’ll  get a context menu, but I found no way to get to
    &lt;em&gt;
     mousedown
    &lt;/em&gt;
    on its own. This means it’s impossible to create a “natural” drag and drop, which isn’t surprising, since same movement is already taken by browser for scrolling.
   &lt;/p&gt;
   &lt;p&gt;
    My test was limited to Nokia 770 tablet, but I doubt results would be much different elsewhere (Fry, can you check your tablet?). It would also be interesting to see what iPhone does, but since I don’t have it either, I can’t tell.
   &lt;/p&gt;
   &lt;p&gt;
    Still I’ll need to rethink a widget for website I’m working on and keep this in mind for my next year project.
   &lt;/p&gt;
  &lt;/div&gt;
 &lt;/body&gt;
&lt;/html&gt;&lt;/p&gt;</summary></entry><entry><title>Dynamically controlling behavior and size of a page</title><link href="/dynamically-controlling-behavior-and-size-of-a-page.html" rel="alternate"></link><updated>2007-12-12T20:37:00+01:00</updated><author><name>markos</name></author><id>tag:,2007-12-12:dynamically-controlling-behavior-and-size-of-a-page.html</id><summary type="html">&lt;p&gt;&lt;html&gt;
 &lt;body&gt;
  &lt;div&gt;
   &lt;p&gt;
    It’s not a secret that Javascript is interpreted and not statically compiled. Personally I find this an advantage that is not used often enough. If you look around the Web you can find plenty of cases to prove this, but I’d like to add another example.
   &lt;/p&gt;
   &lt;p&gt;
    A few months ago I was developing a library which had a goal of providing an improved Javascript experience for standardized components without requiring any knowledge of the language to use. I also wanted to support different load scenarios so library could be smaller when needed.
   &lt;/p&gt;
   &lt;p&gt;
    Sadly I ran out of time before I ended my work to my satisfaction. Still, I’d like to discuss one approach that also demonstrates aspects that I’d like to see used more in the wild.
   &lt;/p&gt;
   &lt;p&gt;
    Let’s start with a demo. I created two almost identical pages. Can you spot the difference between
    &lt;a href="http://markos.gaivo.net/examples/richswitch/index.html" title="First demo"&gt;
     first
    &lt;/a&gt;
    and
    &lt;a href="http://markos.gaivo.net/examples/richswitch/index2.html" title="Second demo"&gt;
     second
    &lt;/a&gt;
    ?
   &lt;/p&gt;
   &lt;p&gt;
    First one simply toggles visibility of the text, while second one does the same with a bit more style. If you look at files, you’ll notice that the only difference is that first calls
    &lt;em&gt;
     &lt;a href="http://markos.gaivo.net/examples/richswitch/switch.js"&gt;
      switch.js
     &lt;/a&gt;
    &lt;/em&gt;
    and second uses
    &lt;em&gt;
     &lt;a href="http://markos.gaivo.net/examples/richswitch/rswitch.js"&gt;
      rswitch.js
     &lt;/a&gt;
    &lt;/em&gt;
    . Both files look the same because they are. In fact, it’s really just one file. Hard link to the rescue for us, Unixheads.
   &lt;/p&gt;
   &lt;p&gt;
    But first a small warning. This code is not production ready. I simplified it to keep example clear and concise. In that capacity I think it will do.
   &lt;/p&gt;
   &lt;p&gt;
    Javascript basically consists of two functions. A
    &lt;em&gt;
     window.onload
    &lt;/em&gt;
    handler that’s triggered when page is loaded and an animation function attached to button. A
    &lt;em&gt;
     window.onload
    &lt;/em&gt;
    handler is a one trick pony. Its main idea is to find Javascript file in DOM and based on the name with which it was loaded set up the execution environment. This is just a fancy name (to make me look smart) for setting a global variable that is private to this name space and possibly loading a few additional resources, like YUI animation support in our case. It is also the first case where not being static helps. We can decide at run time what’s necessary and load only what we need.
   &lt;/p&gt;
   &lt;p&gt;
    However, I find
    &lt;em&gt;
     toggleVisible
    &lt;/em&gt;
    a tad bit more interesting and the reason is its
    &lt;em&gt;
     if
    &lt;/em&gt;
    statement. What happens when we include
    &lt;em&gt;
     switch.js
    &lt;/em&gt;
    in a page?
   &lt;/p&gt;
   &lt;p&gt;
    Well, variable
    &lt;em&gt;
     rich
    &lt;/em&gt;
    remains set to
    &lt;em&gt;
     false
    &lt;/em&gt;
    and YUI components don’t get loaded. This means
    &lt;em&gt;
     YAHOO.util
    &lt;/em&gt;
    and its descendants aren’t defined. Yet as we’ve seen from first demo page script works just fine. Reason for this is that
    &lt;em&gt;
     if
    &lt;/em&gt;
    statement in
    &lt;em&gt;
     toggleVisible
    &lt;/em&gt;
    evaluates to
    &lt;em&gt;
     false
    &lt;/em&gt;
    and those undefined statements never get reached. This wouldn’t work in a language like Java, which would notice a call to undefined methods at compile time and refuse to finish compile, but it works perfectly fine in Javascript.
   &lt;/p&gt;
   &lt;p&gt;
    Of course if rich was set true, then we load YUI files. It might happen with this code that we press button before they get loaded, which is one of the reasons why this isn’t a production quality code, but if we assume for a moment that they did, then those same lines in
    &lt;em&gt;
     toggleVisible
    &lt;/em&gt;
    are perfectly fine and it works as hopefully seen on second page.
   &lt;/p&gt;
   &lt;p&gt;
    We therefore have a page where we control its behavior and size only by the way we call javascript file. There’s literally only one letter of difference. With dynamic loading of resources and cordoning potentially nonexistent methods we could fairly easily create a spectrum of possibilities where our users could choose their own compromise between functionality and its price in terms of page size and speed or better handle differences between mobile and desktop browsers.
   &lt;/p&gt;
  &lt;/div&gt;
 &lt;/body&gt;
&lt;/html&gt;&lt;/p&gt;</summary></entry><entry><title>Flash inside of WYSIWYG HTML editor</title><link href="/flash-inside-of-wysiwyg-html-editor.html" rel="alternate"></link><updated>2007-07-09T16:23:00+02:00</updated><author><name>markos</name></author><id>tag:,2007-07-09:flash-inside-of-wysiwyg-html-editor.html</id><summary type="html">&lt;p&gt;&lt;html&gt;
 &lt;body&gt;
  &lt;div&gt;
   &lt;p&gt;
    Has anyone succeeded in getting a flash file to execute inside of (any) WYSIWYG in-browser editor?
   &lt;/p&gt;
   &lt;p&gt;
    It doesn’t work for me and I can think of at least one reason why it shouldn’t (security leak), but has anyone done it anyway?
   &lt;/p&gt;
  &lt;/div&gt;
 &lt;/body&gt;
&lt;/html&gt;&lt;/p&gt;</summary></entry><entry><title>Google Gears Goodies</title><link href="/google-gears-goodies.html" rel="alternate"></link><updated>2007-05-31T15:00:00+02:00</updated><author><name>markos</name></author><id>tag:,2007-05-31:google-gears-goodies.html</id><summary type="html">&lt;p&gt;&lt;html&gt;
 &lt;body&gt;
  &lt;div&gt;
   &lt;p&gt;
    It’s an expected fact of a geek life that interesting technologies and gadgets appear when you don’t have either means or time to play with them. No surprise then that
    &lt;a href="http://code.google.com/apis/gears/index.html"&gt;
     Google Gears
    &lt;/a&gt;
    was announced exactly at such a time for me. As you’ve probably read elsewhere, Google Gears is a browser extension for Firefox and Internet Explorer (with Safari coming up) which lets developers create web applications that can also run offline on Windows, Mac OS X and Linux.
   &lt;/p&gt;
   &lt;p&gt;
    Google isn’t the first company doing something like this. Adobe has Apollo, Microsoft is working on its own thing, Mozilla added support for offline storage in version 2 of the fox and there are some less well known attempts like Dojo’s. What makes it special are few things.
   &lt;/p&gt;
   &lt;p&gt;
    First, unlike Apollo or Firefox, it’s not a special environment and it’s as cross-browser and cross-platform as it gets these days. Google is also trying to build an industry support for this and Adobe already
    &lt;a href="http://shebanation.com/2007/05/30/google-gears/"&gt;
     announced
    &lt;/a&gt;
    it will support Gears API in Apollo. Same has
    &lt;a href="http://ajaxian.com/archives/audible-ajax-episode-21-dojo-offline-on-google-gears"&gt;
     already been done
    &lt;/a&gt;
    by Dojo Toolkit. There’s also
    &lt;a href="http://erik.eae.net/archives/2007/05/30/19.06.10/#comments"&gt;
     an intention
    &lt;/a&gt;
    to make it an open standard by submitting proposal to WHATWG/W3C (and hopefully them accepting it).
   &lt;/p&gt;
   &lt;p&gt;
    Personally, I can’t wait to play with WorkerPool API (which seems to be overlooked in all the excitement). Having a possibility of running time-intensive operations in a background without the fear of triggering “unresponsive script” dialog is a wish come true. Even though you can’t access objects
    &lt;em&gt;
     document
    &lt;/em&gt;
    and
    &lt;em&gt;
     window
    &lt;/em&gt;
    (and hence any part of the DOM). Reason for this is that background scripts don’t share any execution state and hence can’t all access unique objects like aforementioned ones.
   &lt;/p&gt;
   &lt;p&gt;
    This might limit usefulness of the API somewhat, but there are still plenty of uses that come to my mind. What also comes to my mind is a problem, that isn’t really technological. Web applications gave impression to public of being fairly safe to use even on public computers (which isn’t really true) and I fear many won’t understand that new tools may now store private data where they don’t expect or want them to.
   &lt;/p&gt;
  &lt;/div&gt;
 &lt;/body&gt;
&lt;/html&gt;&lt;/p&gt;</summary></entry><entry><title>Problem with public javascript hosting</title><link href="/problem-with-public-javascript-hosting.html" rel="alternate"></link><updated>2007-03-06T16:56:00+01:00</updated><author><name>markos</name></author><id>tag:,2007-03-06:problem-with-public-javascript-hosting.html</id><summary type="html">&lt;p&gt;&lt;html&gt;
 &lt;body&gt;
  &lt;div&gt;
   &lt;p&gt;
    Yahoo recently
    &lt;a href="http://yuiblog.com/blog/2007/02/22/free-yui-hosting/"&gt;
     announced
    &lt;/a&gt;
    free public hosting of YUI library, just like AOL
    &lt;a href="http://blog.dojotoolkit.org/2006/01/30/dojo-iamalpha-and-cdns"&gt;
     did
    &lt;/a&gt;
    a while ago for Dojo toolkit. A great move. You don’t have to pay bandwidth for hosting YUI and there’s a better likelihood that scripts will already be in visitors browser cache, since some other previously visited page might have used them too.
   &lt;/p&gt;
   &lt;p&gt;
    However there’s a real downside to it. What happens if Yahoo servers are unaccessible or connection to them is just slow?
   &lt;/p&gt;
   &lt;p&gt;
    If you’re lucky, then its former and the page will be rendered quickly but with some (javascript) functionality missing. If later, then it might take forever to render a page since modern browsers can’t and won’t do it until all javascript has been loaded.
   &lt;/p&gt;
   &lt;p&gt;
    This might seem an unlikely scenario, unless you’ve been around the last time when access problems to Google Analytics stopped displaying a large part of slovenian web, least important of which being this very blog. Yahoo is not stupid, but neither is Google and problem can literally appear anywhere between their servers and your visitors computer.
   &lt;/p&gt;
   &lt;p&gt;
    So what can be done if this possibility is not acceptable to you, but you’d still want to use free hosting?
   &lt;/p&gt;
   &lt;p&gt;
    Nothing pretty it seems. The only thing that I can think of is to add local links to yui, put them together with Yahoo links at the bottom of the page and trigger Javascript when content has been loaded. Then you only have to wait for YUI objects to appear before you start processing your scripts.
   &lt;/p&gt;
   &lt;p&gt;
    This way you can probably avoid crippled or blank pages, but you’re still paying for the bandwidth. Unless of course you go one step further and include local links only when Yahoo objects don’t appear in a reasonable amount of time.
   &lt;/p&gt;
   &lt;p&gt;
    Does anyone have any idea how to solve this problem gracefully?
   &lt;/p&gt;
  &lt;/div&gt;
 &lt;/body&gt;
&lt;/html&gt;&lt;/p&gt;</summary></entry><entry><title>Free book</title><link href="/free-book.html" rel="alternate"></link><updated>2006-12-30T18:36:00+01:00</updated><author><name>markos</name></author><id>tag:,2006-12-30:free-book.html</id><summary type="html">&lt;p&gt;&lt;html&gt;
 &lt;body&gt;
  &lt;div&gt;
   &lt;p&gt;
    I’ll give
    &lt;a href="http://www.oreilly.com/catalog/jscript4/" title="Book's homepage"&gt;
     4th edition
    &lt;/a&gt;
    of Javascript, the Definitive Guide by David Flanagan to person who emails me first.
   &lt;/p&gt;
   &lt;p&gt;
    The book is in excellent condition even though it’s been in my hands a lot and I can only recommend it to anyone who wants to learn Javascript. I’d still cling to it, if I haven’t received 5th edition as Christmas gift.
   &lt;/p&gt;
   &lt;p&gt;
    Lucky recipient will be able to claim it at next
    &lt;a href="http://web.zen.si/"&gt;
     Wednesday talk
    &lt;/a&gt;
    , whenever it will be.
   &lt;/p&gt;
  &lt;/div&gt;
 &lt;/body&gt;
&lt;/html&gt;&lt;/p&gt;</summary></entry><entry><title>Preventing download of javascript on mobile web</title><link href="/preventing-javascript-download-on-mobile-web.html" rel="alternate"></link><updated>2006-10-29T21:55:00+01:00</updated><author><name>markos</name></author><id>tag:,2006-10-29:preventing-javascript-download-on-mobile-web.html</id><summary type="html">&lt;p&gt;&lt;html&gt;
 &lt;body&gt;
  &lt;div&gt;
   &lt;p&gt;
    Every year I spend a few weeks somewhere where internet connection is either slow or metered and expensive. Usually it’s both which makes me rather twitchy when it comes to big web page sizes. Yet I’m also certain that my new web home, however it may turn out at the end, will have a significant chunk of it written in Javascript. None of it necessary for working, but more than I’d probably like to download over flimsy mobile phone connection.
   &lt;/p&gt;
   &lt;p&gt;
    The problem are not really old mobile browsers which don’t support Javascript. They won’t download any of it anyway. The question is how to prevent eager browsers, who would, from downloading this stuff when you don’t want them to. My first, rather primitive attempt was
    &lt;a href="http://markos.gaivo.net/examples/envcheck/index.html" title="Demo of javascript ondemand loading depending on media"&gt;
     this demonstration
    &lt;/a&gt;
    , which only works in Opera 9, Safari and Firefox, but most certainly doesn’t work in all browsers.
   &lt;/p&gt;
   &lt;p&gt;
    What it does is check font size of a title and based on its value resolves which media style sheet was used. If it was
    &lt;em&gt;
     mobile.css
    &lt;/em&gt;
    , which is used only when media is set to
    &lt;em&gt;
     handheld
    &lt;/em&gt;
    , then it was probably done from a mobile environment, so it includes the mobile version of a Javascript or it could, if I wanted, none at all.
   &lt;/p&gt;
   &lt;p&gt;
    There are several problems with this approach. First one is that it doesn’t recognize notebook users connecting over a  cellphone. It can’t really, since browser environment is literally the same, unless it would try to measure latency and bandwidth of page elements and guess from those results, which is neither easy nor reliable. 3G networks can be rather fast and have a better latency than a wired connection from somewhere like Tanzania.
   &lt;/p&gt;
   &lt;p&gt;
    But let’s say we don’t care about this case. We can always turn Javascript off in Firefox if it’s important enough to us, which leads us to the next problem. Support for handheld media type is still rather spotty. If browser doesn’t support it, it may load the wrong style sheet if any at all and the wrong CSS value results in wrong turn in Javascript. However
    &lt;em&gt;
     handheld media
    &lt;/em&gt;
    support is getting better. Since I decided from the start that my personal page is a good place where leading edge can also be a bit of bleeding one, that is good enough. On a different site this probably wouldn’t be true.
   &lt;/p&gt;
   &lt;p&gt;
    So it sort of works in principle, but it is crude and error prone. Javascript check is not self-contained and I could easily break it by changing font size value of a title in CSS files while forgetting to do a corresponding correction in code. What would be much better is to learn from the browser which media types style sheets were actually used and act accordingly. Now that would be grand.
   &lt;/p&gt;
   &lt;p&gt;
    There are two ways you could go about this. My first go was finding style nodes in DOM and looking at their
    &lt;em&gt;
     disabled
    &lt;/em&gt;
    property, which is commonly used in style sheet switchers for turning sheets on and off. It doesn’t work, since ‘wrong’ media types in Firefox are ignored, not disabled. Their
    &lt;em&gt;
     disabled
    &lt;/em&gt;
    value is still set to
    &lt;em&gt;
     false
    &lt;/em&gt;
    .
   &lt;/p&gt;
   &lt;p&gt;
    A proper way of doing it would be using DOM Style Sheets methods. Basic idea is to compare actual values as set in the page with values read from style sheets and resolving which ones were used. While not exactly trivial, by little forethought it can be made to work fine in Opera and Firefox. It can also work in Explorer using its own methods, but it’s a pain to make it  work in Safari, which in this case is not only an incompetent liar, it’s also lying in some weird accent. If you’d like to learn more about it, then there’s a
    &lt;a href="http://www.howtocreate.co.uk/tutorials/javascript/domstylesheets" title="Problems with DOM Style Sheets use"&gt;
     great
    &lt;/a&gt;
    page describing current state but the gist of it is that you can’t rely on methods being there and even when they are, in some form or another, they might not work reliably (Safari) or might produce weird results (yup, Safari again).
   &lt;/p&gt;
   &lt;p&gt;
    Well, it could still work, but would require an unreasonable amount of code. Hence I made a different tradeoff, which can be seen
    &lt;a href="http://markos.gaivo.net/examples/envcheck/index2.html" title="Second attempt"&gt;
     here
    &lt;/a&gt;
    . A bit less automation for a lot less code. It keeps the idea of first demo with a small twist. First rule of every media style sheet targets the same element that gets created by Javascript if necessary and compares its font size value with those found in style sheets. It returns media types of all sheets where this value was found.
   &lt;/p&gt;
   &lt;p&gt;
    The end result certainly isn’t perfect or pretty, but it keeps amount of bookkeeping to minimum and limited to CSS files. Even using a “safe” property like font size can lead to problems (e.g. 0.9em is sometimes interpreted as 0.90em), but nothing difficult to overcome.
   &lt;/p&gt;
   &lt;p&gt;
    It might not be of production quality, but it will work as good starting point for further exploration.
   &lt;/p&gt;
  &lt;/div&gt;
 &lt;/body&gt;
&lt;/html&gt;&lt;/p&gt;</summary></entry><entry><title>Remembering parts of a page</title><link href="/remembering-parts-of-a-page.html" rel="alternate"></link><updated>2006-07-20T18:47:00+02:00</updated><author><name>markos</name></author><id>tag:,2006-07-20:remembering-parts-of-a-page.html</id><summary type="html">&lt;p&gt;&lt;html&gt;
 &lt;body&gt;
  &lt;div&gt;
   &lt;p&gt;
    Every now and then, but especially when I build pages that combine index of images together with a preview of one of them, I wish there was a way to tell a browser to remember a part of a current page and apply it at appropriate place on the next one from the same domain which also has same ID.
   &lt;/p&gt;
   &lt;p&gt;
    The gist of a problem is that I sometimes want bookmark-ability of separate pages without throwing away a product of an expensive operation. I want my cake and eat it too.
   &lt;/p&gt;
   &lt;p&gt;
    This is impossible, since there’s no way to actually store DOM objects and I’m not even sure it’s a good idea. Nevertheless, I certainly do miss the feature.
   &lt;/p&gt;
  &lt;/div&gt;
 &lt;/body&gt;
&lt;/html&gt;&lt;/p&gt;</summary></entry><entry><title>Sense and sensibility of javascript libraries</title><link href="/sense-and-sensibility-of-javascript-libraries.html" rel="alternate"></link><updated>2006-06-22T14:01:00+02:00</updated><author><name>markos</name></author><id>tag:,2006-06-22:sense-and-sensibility-of-javascript-libraries.html</id><summary type="html">&lt;p&gt;&lt;html&gt;
 &lt;body&gt;
  &lt;div&gt;
   &lt;p&gt;
    As mentioned in previous post, I think @media javascript panel deserves its own post and this large blob of text that follows is my take on it. You can also read
    &lt;a href="http://www.quirksmode.org/blog/archives/2006/06/media_impressio.html"&gt;
     PPK’s
    &lt;/a&gt;
    view or Paul Hammond’s
    &lt;a href="http://www.paulhammond.org/2006/06/atmedia2/javascript"&gt;
     transcription
    &lt;/a&gt;
    . I’ll be relying on them to augment my memory.
   &lt;/p&gt;
   &lt;p&gt;
    I started my programming career pretty far from web stack and it took me a while to accept that this is what I’m mostly doing. As I listened to the panelists, I was wondering if this may be the reason why I perceive things a bit differently, although I doubt it. Still, @media javascript panel raised some good questions.
   &lt;/p&gt;
   &lt;p&gt;
    &lt;strong&gt;
     Are Javascript libraries unnecessary?
     &lt;br/&gt;
    &lt;/strong&gt;
    &lt;br/&gt;
    It seems obvious that panelists would be disinclined to say yes, since they are the people who need them the least. I don’t use them yet either, but on the other hand I’m certain that they are needed and that I eventually will. Their proliferation is one of more obvious confirmations for this and even if some of them are pretty daft (especially
    &lt;a href="http://code.google.com/webtoolkit/"&gt;
     those
    &lt;/a&gt;
    who try to twist Javascript to look and behave like some other language), it doesn’t follow that all of them are.
   &lt;/p&gt;
   &lt;p&gt;
    I don’t buy the argument that they obscure too much. I don’t see what would distinguish them from programming libraries used in other environments. You don’t use them if you don’t need to, but it also doesn’t make sense to develop a complex piece of code, if there’s an existing version out there, which was tested and debugged by many and is actively maintained.
   &lt;/p&gt;
   &lt;p&gt;
    If you hit a bug in a library, you are left with same situation as otherwise. You can report a bug and wait for the fix or dive into code yourself and try to solve it. As with open source software you’re actually better off than you’d be if you worked with closed source.
   &lt;/p&gt;
   &lt;p&gt;
    Nothing actually stops you from learning how the library works, if that’s what you want or need. It would be great if we all knew intrinsically what is happening on the computer and how the whole process of displaying a page works, but let’s face it, we don’t and there’s for all intents and purposes a huge black box underneath that sort of does what we want and we sort of understand why and how it does it. Using a well developed and documented library doesn’t change much.
   &lt;/p&gt;
   &lt;p&gt;
    I also don’t buy
    &lt;a href="http://simon.incutio.com/"&gt;
     Simon Willison’s
    &lt;/a&gt;
    argument that libraries should be obsolete and that browser should be enough. Libraries happened because browsers take too much time to develop and spread and I don’t see this changing any time soon. It would be nice, if parts of todays libraries were standardized in tomorrow’s browsers, but I’m sure innovative people out there will always find stuff they’d like to do which their current environment doesn’t let them. And when that stuff can be generalized, it should be put in a library.
   &lt;/p&gt;
   &lt;p&gt;
    &lt;strong&gt;
     So what’s really wrong with libraries?
     &lt;br/&gt;
    &lt;/strong&gt;
    &lt;br/&gt;
    One problem is that many of them are quite large and it may take a while before they get downloaded. Even worse, downloaded versions don’t get shared when used by different websites, since they don’t come from the same network resource. However, as already said, I think circumventing this problem by simply using an installed version on some other servers (you can use Dojo installed on AOL’s server) is daft too.
   &lt;/p&gt;
   &lt;p&gt;
    Computer networks are fairly fragile and in some parts of the world even more so. It’s not a rare event when at least parts of the world are inaccessible. Do you really want to bet your success on your visitors accessibility of some resource completely away from your control?
   &lt;/p&gt;
   &lt;p&gt;
    I think caching is not a bad idea, but it needs support from browsers. The same problem could be solved by giving each library plus its version a unique fingerprint, which browsers could use to identify possible hits in their cache. The most nonhackish way of calling a script that I could come up with was:
    &lt;br/&gt;
    &lt;code&gt;
     &lt;br/&gt;
     &amp;lt;script type="text/javascript" src="http://some.server.on.the.net/coollib.js?jslibPrint=sdrt32svg"&amp;gt;&amp;lt;/script&amp;gt;
    &lt;/code&gt;
    &lt;br/&gt;
    A different approach would be to simply include most popular Javascript libraries as a part of a browser installation. But this approach has at least two downsides. First, it would be limited to chosen few and second, which is one of my real objections to current crop of libraries out there, you’d need a fairly mature libraries.
   &lt;/p&gt;
   &lt;p&gt;
    One problem with current libraries which was pointed out is namespace collision. It is not a new problem and although some languages (Python, Java…) provide a mechanism to avoid it, others like C don’t. For me even more annoying is lack of stable APIs. It’s simply hard to rely on a library that changes interfaces too often.
   &lt;/p&gt;
   &lt;p&gt;
    But none of these problems is either new or insurmountable. I think libraries are here to stay and that’s a good thing. I prefer a web with plenty of well-done web sites than one with a handful of masterpieces swimming in a sea of crap.
   &lt;/p&gt;
   &lt;p&gt;
    And
    &lt;a href="http://www.kryogenix.org/"&gt;
     Stuart Langridge
    &lt;/a&gt;
    is right.
    &lt;a href="http://alex.dojotoolkit.org/"&gt;
     Alex Russell
    &lt;/a&gt;
    certainly is (too?) clever.
   &lt;/p&gt;
  &lt;/div&gt;
 &lt;/body&gt;
&lt;/html&gt;&lt;/p&gt;</summary></entry><entry><title>Firefox extensions Javascript conflicts</title><link href="/firefox-extensions-javascript-conflicts.html" rel="alternate"></link><updated>2006-05-29T12:23:00+02:00</updated><author><name>markos</name></author><id>tag:,2006-05-29:firefox-extensions-javascript-conflicts.html</id><summary type="html">&lt;p&gt;&lt;html&gt;
 &lt;body&gt;
  &lt;div&gt;
   &lt;p&gt;
    I like Firefox extensions and use a few myself. Web development without
    &lt;a href="http://chrispederick.com/work/webdeveloper/"&gt;
     Web Developer toolbar
    &lt;/a&gt;
    and
    &lt;a href="http://livehttpheaders.mozdev.org/"&gt;
     LiveHTTPHeaders
    &lt;/a&gt;
    extension would be pretty gruesome. However, there’s a downside to their use that is slowly starting to bother me.
   &lt;/p&gt;
   &lt;p&gt;
    They often influence the way Javascript on page gets executed and can produce weird errors.
   &lt;/p&gt;
   &lt;p&gt;
    I first noticed this while using Web Developer toolbar. Every now and then I got a strange exception, but I didn’t worry too much. After all, it wasn’t really surprising coming from an extension that by its very nature dabbled with the way browser interprets and displays a page and it didn’t really stop the script from working. Not pretty, but you learn to live with it.
   &lt;/p&gt;
   &lt;p&gt;
    Comes this weekend and I get a report that file upload doesn’t work in latest Firefox. I suspected extension conflicts and further examination proved the point. Page worked just fine in the same environment sans extensions.
   &lt;/p&gt;
   &lt;p&gt;
    So what can you do, when you stumble on a problem like that?
   &lt;/p&gt;
   &lt;p&gt;
    Testing your site in various browsers can be troublesome enough. Testing all combinations of extensions even for one browser would simply be impossible. You can’t exactly expect your users to uninstall their extensions just for you, but making workarounds for them doesn’t seem feasible either.
   &lt;/p&gt;
   &lt;p&gt;
    So far I don’t see a good solution. Any ideas?
   &lt;/p&gt;
  &lt;/div&gt;
 &lt;/body&gt;
&lt;/html&gt;&lt;/p&gt;</summary></entry><entry><title>Usefulness of AJAX</title><link href="/usefulness-of-ajax.html" rel="alternate"></link><updated>2006-05-13T07:53:00+02:00</updated><author><name>markos</name></author><id>tag:,2006-05-13:usefulness-of-ajax.html</id><summary type="html">&lt;p&gt;&lt;html&gt;
 &lt;body&gt;
  &lt;div&gt;
   &lt;p&gt;
    At least one participant of our recent
    &lt;a href="ajax-workshop-2.html" title="Previous announcement of AJAX workshop"&gt;
     workshop
    &lt;/a&gt;
    was under impression that I’m an AJAX advocate. It’s certainly a reasonable and not completely wrong conclusion. However, it seems I failed in limited time available to explain my perspective.
   &lt;/p&gt;
   &lt;p&gt;
    As any other useful tool AJAX has its advantages, but it can also create problems when used inappropriately. I won’t dwell on advantages. More than enough has already been said about them. There are three important aspects that still don’t get enough attention and bear repeating.
   &lt;/p&gt;
   &lt;p&gt;
    &lt;strong&gt;
     Write unobtrusive and degradable Javascript.
    &lt;/strong&gt;
    It’s really not that hard with a bit of planning and it makes things easier in the long run. It’s easier to find, fix and change code when it’s cleanly separated from HTML and CSS. I’d expect everyone learned this lesson by now from PHP. Also, creating HTML version first and then carefully improving it with use of Javascript/AJAX can get us maximum reach without sacrificing flexibility.
   &lt;/p&gt;
   &lt;p&gt;
    &lt;strong&gt;
     Pay attention to usability.
    &lt;/strong&gt;
    This one is much harder to get right, but if nothing else, you should have in mind at least next three advices. Show a progress indicator when doing something that might take more than a second. Put action trigger as close as possible to the part of a page it will change, so user has a good chance of noticing it and whenever possible assist them with change indicators like
    &lt;a href="http://www.axentric.com/posts/default/7" title="Example of yellow fade-in"&gt;
     yellow fade-in
    &lt;/a&gt;
    .
   &lt;/p&gt;
   &lt;p&gt;
    &lt;strong&gt;
     Accessibility shouldn’t be forgotten either.
    &lt;/strong&gt;
    This is probably
    &lt;a href="http://domscripting.com/blog/display/64" title="Accessibility problems with DOM manipulation"&gt;
     the hardest problem
    &lt;/a&gt;
    to tackle. It’s the most important reason (but not the only one) why I try to use Javascript/AJAX only when benefits of doing so significantly outweigh the problems it might cause.
   &lt;/p&gt;
   &lt;p&gt;
    Everyone makes mistakes and I certainly have. I’m sure they weren’t last ones either, but we can all strive for better.
   &lt;/p&gt;
  &lt;/div&gt;
 &lt;/body&gt;
&lt;/html&gt;&lt;/p&gt;</summary></entry><entry><title>Hide email address from spammers with Javascript - a new attempt</title><link href="/hide-email-address-from-spammers-with-javascript-a-new-attempt.html" rel="alternate"></link><updated>2006-05-08T12:23:00+02:00</updated><author><name>markos</name></author><id>tag:,2006-05-08:hide-email-address-from-spammers-with-javascript-a-new-attempt.html</id><summary type="html">&lt;p&gt;&lt;html&gt;
 &lt;body&gt;
  &lt;div&gt;
   &lt;p&gt;
    In true Don Quixote fashion, I made a new attempt to make email harvesting more difficult. It won’t work forever, but it will work longer than
    &lt;a href="hide-email-address-from-spammers-with-javascript.html"&gt;
     previous
    &lt;/a&gt;
    one, which hasn’t fail yet either.
   &lt;/p&gt;
   &lt;p&gt;
    This time I use a bit different approach. Instead of replacing spam-proof, but not directly usable email addresses with mail links on page load, I create mail links on page load, but populate them when mouse moves over them. This way they are still perfectly usable, but less likely to be abused. They are also less friendly, since you can’t see email address until you move your pointer over it. But that was the point, to prevent javascript enabled scrappers.
   &lt;/p&gt;
   &lt;p&gt;
    You can download
    &lt;a href="http://markos.gaivo.net/blog/code/mangle2.js"&gt;
     new version
    &lt;/a&gt;
    or check a
    &lt;a href="http://markos.gaivo.net/examples/mangle2.html"&gt;
     demonstration
    &lt;/a&gt;
    on alternative version of my homepage.
   &lt;/p&gt;
  &lt;/div&gt;
 &lt;/body&gt;
&lt;/html&gt;&lt;/p&gt;</summary></entry><entry><title>Javascript enabled spiders</title><link href="/javascript-enabled-spiders.html" rel="alternate"></link><updated>2006-04-07T17:23:00+02:00</updated><author><name>markos</name></author><id>tag:,2006-04-07:javascript-enabled-spiders.html</id><summary type="html">&lt;p&gt;&lt;html&gt;
 &lt;body&gt;
  &lt;div&gt;
   &lt;p&gt;
    One of more popular javascript scripts I’ve written is a simple function that hides an email address from spiders by constructing a mailto link on page load. So far it has worked quite well.
   &lt;/p&gt;
   &lt;p&gt;
    Lately I started to have my doubts about this approach though. There was
    &lt;a href="http://www.google.com/search?hl=en&amp;amp;q=mozilla+google+spider&amp;amp;btnG=Google+Search"&gt;
     a series of articles
    &lt;/a&gt;
    a while ago about Google’s new Mozilla-based spider that I didn’t take too seriously at the time. However, even if not true then, it’s still only a matter of time before a spider like this will show up. The new found popularity of AJAX/Javascript simply guarantees that, since search engines can’t and won’t give up indexing content hidden behind fancy scripts.
   &lt;/p&gt;
   &lt;p&gt;
    Which means that my script will stop working in not so distant future as will all email obfuscating scripts out there. If it can be seen by a human, then it will be seen by a spider. So is there a way to publish my email address without it becoming public through search engines indexes, which is where most spammers seem to get our emails?
   &lt;/p&gt;
   &lt;p&gt;
    I could write a robots.txt file, which would exempt my contact page from being indexed at all. But this is a rather crude approach, since it means nothing on that page will get indexed. I could move email information to a separate page to let other contact data get indexed, but this is hardly any nicer.
   &lt;/p&gt;
   &lt;p&gt;
    What I’d really want is to be able to tell to search engines that only a part of my document is off limits. I don’t think there’s currently a way to do this, but if anyone has an idea how to do it, I’d really like to hear it.
   &lt;/p&gt;
   &lt;p&gt;
    &lt;strong&gt;
     Update:
    &lt;/strong&gt;
    I think all efforts, including mine, to prevent spammers from collecting published addresses are ultimately doomed. The basic premise of all such approaches is to cloak an address in a way that spider can’t see it or can’t recognize it if it does. By basing spider on something like Mozilla, there won’t be any difference between what spider sees and what user does. There’s a similar problem with recognition. As spiders gets smarter, as they invariably do, you’ll be getting ever growing overlap between smartest spiders and stupidest users until it’s big enough to be unacceptable.
   &lt;/p&gt;
   &lt;p&gt;
    So we’ll either put up contact forms or I hope move to defending our inboxes with smart spam filters (those who haven’t yet).
   &lt;/p&gt;
  &lt;/div&gt;
 &lt;/body&gt;
&lt;/html&gt;&lt;/p&gt;</summary></entry><entry><title>Faking body.onload</title><link href="/faking-bodyonload.html" rel="alternate"></link><updated>2006-02-19T11:57:00+01:00</updated><author><name>markos</name></author><id>tag:,2006-02-19:faking-bodyonload.html</id><summary type="html">&lt;p&gt;&lt;html&gt;
 &lt;body&gt;
  &lt;div&gt;
   &lt;p&gt;
    &lt;strong&gt;
     Error:
    &lt;/strong&gt;
    No such file found! Please make sure
    &lt;code&gt;
     http://markos.gaivo.net/blog/code/bodyonload.txt
    &lt;/code&gt;
    exists.
   &lt;/p&gt;
  &lt;/div&gt;
 &lt;/body&gt;
&lt;/html&gt;&lt;/p&gt;</summary></entry><entry><title>Solving javascript i18n as work in progress</title><link href="/solving-javascript-i18n-as-work-in-progress.html" rel="alternate"></link><updated>2005-12-08T14:11:00+01:00</updated><author><name>markos</name></author><id>tag:,2005-12-08:solving-javascript-i18n-as-work-in-progress.html</id><summary type="html">&lt;p&gt;&lt;html&gt;
 &lt;body&gt;
  &lt;div&gt;
   &lt;p&gt;
    A while ago I was moaning about a sad state of javascript i18n tools. When I finally started working on it, I faced a dilemma.
   &lt;/p&gt;
   &lt;p&gt;
    Should I wait until it’s finished and then reveal it like Moses to chosen people? Look guys what I etched with a toothpick during my lunch time break! You know, I was waiting for my Crème Brûlée and had to kill those few pesky minutes.
   &lt;/p&gt;
   &lt;p&gt;
    Or should I choose a more honest approach, showing steps and missteps between embarrassing first version and hopefully usable last?
   &lt;/p&gt;
   &lt;p&gt;
    Well, there’s nothing better than public humiliation to instill some humility so let’s see what is behind the door number two.
   &lt;/p&gt;
   &lt;p&gt;
    The goal is still the same. Develop a short and relatively fast library that allows you to translate javascript code and HTML content and to do so with as little fuss as possible and with a clear separation between HTML, javascript and translations, but without breaking pages in case translation doesn’t exist yet.
   &lt;/p&gt;
   &lt;p&gt;
    And
    &lt;a href="http://markos.gaivo.net/examples/js_i18n/1/translate.js" title="Translation functions"&gt;
     here’s
    &lt;/a&gt;
    my humble start together with a
    &lt;a href="http://markos.gaivo.net/examples/js_i18n/1/index.html" title="Link to demonstration page"&gt;
     simple demo
    &lt;/a&gt;
    . Three functions, two of them a support needed later on. stripStr and stripStrML just strip whitespace at the start and end of string with stripStrML doing it on every line of a given string. We’ll need this later on so we can find strings to translate even if they are enclosed in whitespace to make source display more pretty.
   &lt;/p&gt;
   &lt;p&gt;
    Then there’s a function called _, which takes a string and translates it if javascript object i18nDict exists and has this string as an attribute with a non empty value. Otherwise it just returns the same string, so it doesn’t break page even if translation doesn’t exist in
    &lt;a href="http://markos.gaivo.net/examples/js_i18n/1/i18n.js" title="Translation dictionary"&gt;
     translation object
    &lt;/a&gt;
    . It’s what is usually called a proof of concept prototype.
   &lt;/p&gt;
   &lt;p&gt;
    That’s it for today. I’ll try to post updates every couple of days or so, if progress warrants it.
   &lt;/p&gt;
   &lt;p&gt;
    Update: Follow up
    &lt;a href="look-ma-html-too.html"&gt;
     here
    &lt;/a&gt;
    and
    &lt;a href="news-at-seven-javascript-i18n-that-almost-doesnt-suck.html"&gt;
     here
    &lt;/a&gt;
    .
   &lt;/p&gt;
  &lt;/div&gt;
 &lt;/body&gt;
&lt;/html&gt;&lt;/p&gt;</summary></entry><entry><title>Speed match: JSON vs. XML</title><link href="/speed-match-json-vs-xml.html" rel="alternate"></link><updated>2005-12-05T19:41:00+01:00</updated><author><name>markos</name></author><id>tag:,2005-12-05:speed-match-json-vs-xml.html</id><summary type="html">&lt;p&gt;&lt;html&gt;
 &lt;body&gt;
  &lt;div&gt;
   &lt;p&gt;
    I started playing with AJAX before it got its silly name and true to X I used XML in my application. At least at first.
   &lt;/p&gt;
   &lt;p&gt;
    What I discovered is that flicker caused by processing data and simultaneously writing results to document can be completely removed if I do a Google and fetch javascript object instead (what later became
    &lt;a href="http://www.crockford.com/JSON/index.html"&gt;
     JSON
    &lt;/a&gt;
    ) and use that. Difference was so vivid, I dropped XML almost completely.
   &lt;/p&gt;
   &lt;p&gt;
    Fast forward to autumn. There’s a debate after our regular weekly talk and a question comes up. Why would Google or anyone else for that matter choose to use something else than XML?
   &lt;/p&gt;
   &lt;p&gt;
    Relying on personal experience I offered speed as obvious and most important reason. I couldn’t back it up, but since I’ve seen it with my own eyes, I didn’t doubt it either. It wasn’t the sole reason. I find dabbling with javascript objects simply easier than handling XML and I’ll care about XSLT when javascript in Safari can access it.
   &lt;/p&gt;
   &lt;p&gt;
    I got reminded of our discussion when I read
    &lt;a href="http://www.xml.com/lpt/a/2005/11/30/tuning-ajax-performance.html"&gt;
     this article
    &lt;/a&gt;
    . Read it, if you haven’t yet, because it’s well worth it. Anyhow, I decided to make a new test. I wrote a simple
    &lt;a href="http://markos.gaivo.net/examples/jsbench/test.html"&gt;
     test page
    &lt;/a&gt;
    , that fetches
    &lt;a href="http://markos.gaivo.net/examples/jsbench/jssample.raw"&gt;
     sample json file
    &lt;/a&gt;
    and basically equal
    &lt;a href="http://markos.gaivo.net/examples/jsbench/xmlsample.xml"&gt;
     xml sample
    &lt;/a&gt;
    and measures how much time it takes to fetch same data.
   &lt;/p&gt;
   &lt;p&gt;
    Result?
   &lt;/p&gt;
   &lt;p&gt;
    After 15 minutes of wild reloading in different browsers (Safari 1.3+, FF1.0, IE6) and different local and non-local servers, I can’t see a difference that couldn’t be attributed to latency. It seems browsers have moved on and there’s little reason to avoid using XML today.
   &lt;/p&gt;
   &lt;p&gt;
    So use whatever you like most.
   &lt;/p&gt;
  &lt;/div&gt;
 &lt;/body&gt;
&lt;/html&gt;&lt;/p&gt;</summary></entry><entry><title>Javascript and i18n</title><link href="/javascript-and-internacionalization.html" rel="alternate"></link><updated>2005-11-05T19:15:00+01:00</updated><author><name>markos</name></author><id>tag:,2005-11-05:javascript-and-internacionalization.html</id><summary type="html">&lt;p&gt;&lt;html&gt;
 &lt;body&gt;
  &lt;div&gt;
   &lt;p&gt;
    I’ve been looking for Javascript localization resources on Google and came up fairly empty handed. There seems to be
    &lt;a href="http://www.codeproject.com/aspnet/MultilingualWebsites3.asp#4"&gt;
     little
    &lt;/a&gt;
    useful information and even less useful code. The only thing I found, that is actually usable, is a
    &lt;a href="http://johnnydebris.net/javascripts/i18n.js?frames=no" title="Link to javascript i18n library"&gt;
     library
    &lt;/a&gt;
    by Guido Wesdorp.
   &lt;/p&gt;
   &lt;p&gt;
    I find this utterly amazing after a decade of Javascript being in wide use, although I probably shouldn’t be. A likely explanation for this is that Javascript is most often used for short scripts inside web pages. If used on a multilingual website, it’s usually fairly easy to have separate javascript files for each language.
   &lt;/p&gt;
   &lt;p&gt;
    I expect this will change with rise of more complicated, involved web applications. However, so far AJAX toolkits that seem to spring up these days like mushrooms after rain, have been busy with obviously more important things like animations.
   &lt;/p&gt;
   &lt;p&gt;
    I could be wrong. In fact, I hope I’m wrong. Is there a javascript i18n library with following characteristics:
   &lt;/p&gt;
   &lt;ul&gt;
    &lt;li&gt;
     easy to use
    &lt;/li&gt;
    &lt;li&gt;
     supports translation of javascript code and HTML
    &lt;/li&gt;
    &lt;li&gt;
     small and relatively fast
    &lt;/li&gt;
    &lt;li&gt;
     translations are separated from HTML and javascript code
    &lt;/li&gt;
    &lt;li&gt;
     handles properly nodes with superfluous whitespace and those where it can’t be collapsed
    &lt;/li&gt;
    &lt;li&gt;
     supports translation of nodes with other HTML tags as ancestors (not only text nodes)
    &lt;/li&gt;
   &lt;/ul&gt;
   &lt;p&gt;
    Guido’s library is a good tool that meets many of these needs, but sadly not all of them. Writing my own one seems to be the only solution.
   &lt;/p&gt;
  &lt;/div&gt;
 &lt;/body&gt;
&lt;/html&gt;&lt;/p&gt;</summary></entry><entry><title>Hide email address from spammers with Javascript</title><link href="/hide-email-address-from-spammers-with-javascript.html" rel="alternate"></link><updated>2005-09-11T15:59:00+02:00</updated><author><name>markos</name></author><id>tag:,2005-09-11:hide-email-address-from-spammers-with-javascript.html</id><summary type="html">&lt;p&gt;&lt;html&gt;
 &lt;body&gt;
  &lt;div&gt;
   &lt;p&gt;
    &lt;strong&gt;
     Update: I
     &lt;a href="hide-email-address-from-spammers-with-javascript-a-new-attempt.html"&gt;
      published
     &lt;/a&gt;
     a new, more safe but less friendly version of this script.
    &lt;/strong&gt;
   &lt;/p&gt;
   &lt;p&gt;
    Wouldn’t it be nice, if you could post your email address on your web site without worrying spammers will pick it up?
   &lt;/p&gt;
   &lt;p&gt;
    Now you can, by applying a little bit of javascript to your web page. Just import
    &lt;a href="/blog/code/mangle.js" title="Javascript file with mangle function"&gt;
     this javascript file
    &lt;/a&gt;
    in head of your document and call
    &lt;em&gt;
     mangle()
    &lt;/em&gt;
    inside your onload handler. What it does, is replace elements of form
    &lt;br/&gt;
    &lt;code&gt;
     &lt;br/&gt;
     &amp;lt;span class="change"&amp;gt;billg at microsoft dot com&amp;lt;/span&amp;gt;
    &lt;/code&gt;
    &lt;br/&gt;
    with
    &lt;br/&gt;
    &lt;code&gt;
     &lt;br/&gt;
     &amp;lt;a href="mailto:billg@microsoft.com"&amp;gt;billg@microsoft.com&amp;lt;/a&amp;gt;
    &lt;/code&gt;
   &lt;/p&gt;
   &lt;p&gt;
    There are few caveats to its use. You’re not allowed to use any HTML tag inside of span blocks, which have class set to change. The script also expects such blocks to have only one class definition. If change is only part of class attribute value, this script won’t work.
   &lt;/p&gt;
   &lt;p&gt;
    You are free to use script as you please and to make any changes necessary. But if you choose to replace “at” and “dot” as delimiters, pick replacements that make address easily recognizable for those who don’t use javascript.
   &lt;/p&gt;
   &lt;p&gt;
    &lt;em&gt;
     Note: The reason why this script works is that spammers use programs which search for email like pattern in page. They don’t interpret pages using javascript interpreter, since it would make collecting addresses significantly slower and more expensive.
    &lt;/em&gt;
   &lt;/p&gt;
   &lt;p&gt;
    &lt;em&gt;
     Update: Jay Samec let me know there’s a bug in my code, since it didn’t handle emails with multiple dots (e.g. those with subdomains). Script has been fixed now.
    &lt;/em&gt;
   &lt;/p&gt;
   &lt;p&gt;
    &lt;em&gt;
     Update 2: Holger Rindermann pointed out another bug and provided a patch to fix it that is now a part of the script.
    &lt;/em&gt;
   &lt;/p&gt;
  &lt;/div&gt;
 &lt;/body&gt;
&lt;/html&gt;&lt;/p&gt;</summary></entry></feed>